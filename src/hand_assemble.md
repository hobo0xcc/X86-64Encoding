# ハンドアセンブル
ここまででx86-64の構造を大体把握できたと思うので、実際にハンドアセンブルをしてみましょう!

ハンドアセンブルというのは、人間がアセンブリを機械語にすることです。
1960〜1970年代頃には、実際にハンドアセンブルが行われていたそうです。

機械語の仕組みを把握していればさほど難しいことではないので、早速やってみましょう。

```x86asm
mov  eax, 10
```

このコードを機械語にします。

このコードのオペランドは、`r32, imm32`と解釈することができます。
r32は32bitのレジスタで、imm32は32bitの即値です。

インテルのマニュアルでmov命令を探してみてください。
マニュアルのA.2.5にオペコードのマップが載っているので、それを見るのも良いでしょう。
mov命令の`r32, imm32`のオペコードを見てみると、`B8+rd id`とあります。

`+rd`というのは、32bitの[レジスタ番号](./register)を左側のオペコードに加算することを表しています。

b, w, d, oが左から8bit, 16bit, 32bit, 64bitを表しています。

次の`id`というのは即値を表しています。
dは32bitのことなので、32bitの即値です。

つまり、このコードの機械語にすると、`B8+レジスタ番号(32bit) 即値(32bit)`という並びになります。

eaxの番号は`000`なので、`B8`、10は16進数で`0A`となり、即値は32bitなので`0A000000`。

機械語は`B80A000000`となります。

この機械語をバイナリエディタに入力して逆アセンブラ(64bit)に読み込ませると先程のコードがでてくるはずです。
ndisasmは`-b 64`という引数を与えないと64bitにならないので注意してください。

次は以下のコードをアセンブルしてみましょう。

```x86asm
add  dword [rbp-16], eax
```

これは`add  r/m32, r32`となり、オペコードは`01 /r`となっています。
/rはModR/Mが続き、RegとR/Mフィールドを両方使用することを表しています。

ModR/Mは、R/Mフィールドがrbpの番号`101`となり、Disp8があるので、Modが`[R/M+Disp8]`を表す`01`となり、r32がeaxなので、Regがeaxの番号`000`となります。

このコードのModR/Mは`01000101`、16進数で`45`となります。

そして、Disp8が`-16`なので、Displacementが16進数の`F0`になります。

機械語は`0145F0`になります。

アセンブラも実行する順番は変わりますが、これと同じような感じで機械語を生成しています。

個人的には、このハンドアセンブルは映画にでてくるような凄腕ハッカー感があって楽しいです。